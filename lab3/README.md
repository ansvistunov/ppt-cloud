# Лабораторная работа №3

## Цель
1. Развернуть готовое приложение (исходный репозиторий https://github.com/docker/docker-nodejs-sample.git, модифицированное приложение находится в папке docker-nodejs-sample) в кластере k8s
2. Обеспечить доступ к развернутому приложению через LoadBalancer
3. Обеспечить доступ к развернутому приложению через ingress-nginx контроллер

## Модификация кода программы
Все необходимые изменения в код уже внесены:
1. Код адаптирован для работы с облачным postgresql (добавлена обработка столбца section в таблице  todo_items)
2. При выборке из БД списка, к ним добавляется имя того узла, на котором происходит выполнение. Необходимо для быстрой визуальной иллюстрации механизма балансировки нагрузки
3. Добавлен endpoint /name, по которому возвращается имя того узла, на котором произошло выполнение. Дополнительный способ визуальной иллюстрации механизма балансировки нагрузки
4. Добавлен endpoint /stop, который завершает выполнение текущего процесса nodejs. Используется для эмуляции выхода одного из экземпляров сервиса из строя, для иллюстрации механизмов оркестратора по автоматическому восстановлению

## Подготовка к выполнению работы
Для выполнения работы нам потребуется выполнить подключение к заранее развернутому кластеру kubernetes. Сделать это можно различными способами, мы будем использовать настройку подключения с помощью консоли yandex cloud (yc). Для этого консоль нужно сначала установить. Здесь и далее будут приводиться команды для ОС Linux, если вам требуется установить консоль для узла под управлением другой ОС, обратитесь к инструкции: https://cloud.yandex.ru/ru/docs/cli/operations/install-cli

Установка yc
```bash
curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
```
Настройка параметров подключения
```bash
yc init
```

Идем по предложенной ссылке, получаем токен, вводим его  
выбираем облако ansvistunov  
и каталог unn-course  
Don't set default zone  

Проверяем подключение
```bash
yc config list
```

Строим параметры подключения к кластеру.   
Если вы подключаетесь с машины, развернутой в облаке (параметры подключения вам дал преподаватель), для подключения используйте команду
```bash
yc managed-kubernetes cluster get-credentials unn-cloud-k8s --internal
```

Если вы подключаетесь с внешней машины (например, с личного компьютера), используйте команду:
```bash
yc managed-kubernetes cluster get-credentials unn-cloud-k8s --external
```

Проверяем подключение к кластеру - выведем информацию об кластере
```bash
kubectl cluster-info
kubectl get pods
```

## Публикация приложения в кластере
Для того, чтобы опубликовать приложение нам нужен образ публикуемого приложения и конфигурационные файлы, описывающие желаемую конфигурацию. Приложение находится в папке docker-nodejs-sample, вы можете его модифицировать (если хотите это сделать) собрать образ и размесить его в репозитории yandex cloud (см. lab2), или использовать уже подготовленный образ, он называется todo-app-with-stop:latest.  
Все изменения мы будем делать в пространстве имен ns, обратите на это внимание 
1. Убедимся, что нам доступен secret, в котором лежат параметры подключения к postgres
```bash
kubectl --namespace ns get secret k8s-secret
```

2. Изучите файлы конфигурации (lab3/k8s/lb). Файл todo-app-template.yaml содержит шаблон для развертывания приложения, а файл load-balances-template.yaml - шаблон для развертывания LoadBalancer. Эти файлы содержат параметры, которые в них необходимо подставить:
$STUDENT - ваша фамилия, которая будет включена как часть имени приложения   
$REGISTRY_ID - идентификатор реестра образов, из которого будет загружен образ вашего приложения (получите его у преподавателя)

Подставить параметры можно вручную, или можно воспользоваться специальной утилитой. Для этого сначала определим переменные окружения:

```bash
export STUDENT=<ваша фамилия>
export REGISTRY_ID=<идентификатор реестра - спросите у преподавателя>
```

и затем воспользуемся envsubst для подстановки значений переменных окружения в наши файлы шаблонов:

```bash
envsubst < todo-app-template.yaml > todo-app.yaml
envsubst < load-balancer-template.yaml > load-balancer.yaml
```

В результате вы получите два файла: todo-app.yaml, содержащий описание Deployment для вашего приложения и load-balancer.yaml, содержащий связанный с ним LoadBalancer

3. Развернем приложение:
```bash
kubectl apply -f todo-app.yaml -n ns
```

Убедимся, что приложение развернуто:
```bash
kubectl get pods -n ns
kubectl describe deployment lab-k8s-<ваша фамилия> -n ns
```

## Развертывание LoadBalancer
Чтобы обеспечить доступ к нашему приложению извне кластера, развернем для него LoadBalancer.

```bash
kubectl apply -f load-balancer.yaml -n ns 
```

Убедимся, что сервис (LoadBalancer) развернулся:
```bash
kubectl describe service lab-k8s-<ваша фамилия> -n ns
kubectl get svc -n ns
```

Через некоторое время, вашему сервису будет назначен внешний ip-адрес (External IP)
Проверим, что сервис по нему отвечает:
```bash
curl http://xxx.xxx.xxx.xxx/name
```

Поскольку мы развернули всего один экземпляр сервиса, отвечать будет толь ко это экземпляр. Отредактируйте файл todo-app.yaml, измените параметр 
```yaml
replicas: 1
``` 
поставьте вместо 1 значение 4 и снова разверните приложение

```bash
kubectl apply -f todo-app.yaml -n ns
```

Будет развернуто 4 экземпляра вашего приложения. Изменение числа развернутых экземпляров (подов) может также быть выполнено командой

```bash
kubectl scale deploy lab-k8s-<ваша фамилия> -n ns --replicas=4
```

Попробуйте последовательно запрашивать  
```bash
watch curl http://xxx.xxx.xxx.xxx/name
```
вы увидите, что ответ вашего сервиса меняется (отвечают разные экземпляры)

Если вы ошиблись в конфигурации, и вам нужно удалить приложение и сервис, вы можете сделать это командами:
```bash
kubectl delete deployment lab-k8s-<ваша фамилия> -n ns
kubectl delete service lab-k8s-<ваша фамилия> -n ns
```

## Публикация сервиса с помощью ingress
При публикации сервиса с помощью LoadBalancer, каждый опубликованный сервис получает свой ip-адрес и именно по нему они разделяются. Альтернативным вариантом является разделение по путям или по именам. Мы будем использовать разделение по именам. Для каждого сервиса мы будем использовать свой собственный домен 4-го уровня вида <ваша фамилия>.nginx.cloud-course.ru.
Удалим ранее созданный LoadBalancer:
```bash
kubectl delete service lab-k8s-<ваша фамилия> -n ns
```
Для развертывания сервиса перейдите в каталог lab3/k8s/ingress. Изучите шаблоны файлов конфигурации. Шаблоны включают в себя шаблон для сервиса и шаблон для развертывания ресурса ingress. 

воспользуемся envsubst для подстановки значений переменных окружения в наши файлы шаблонов:
```bash
envsubst < node-template.yaml > node.yaml
envsubst < ingress-template.yaml > ingress.yaml
```

Развернем сервис и ingress:
```bash
kubectl apply -f node.yaml -n ns
kubectl apply -f ingress.yaml -n ns
```

Убедимся, что развертывание произошло корректно (оно может занять некоторое время)
```bash
kubectl get endpoints -n ns 
```

Перейдем на страницу с нашим приложением: https://<ваша фамилия>.nginx.cloud-course.ru  

Убедимся, что работает балансировка нагрузки
```bash
curl https://<ваша фамилия>.nginx.cloud-course.ru/name
```

Убедимся, что мы можем остановить экземпляр сервиса:
```bash
curl https://<ваша фамилия>.nginx.cloud-course.ru/stop
```

Убедитесь, что оркестратор восстановил конфигурацию:
```bash
kubectl get pods -n ns
kubectl describe deployment lab-k8s-<ваша фамилия> -n ns
```

Если по какой-то причине вам нужно перезапустить ваше приложение, вы можете воспользоваться командой:

```bash
kubectl -n ns rollout restart deployment/lab-k8s-<ваша фамилия>
```



