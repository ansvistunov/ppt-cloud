# Элементарное введение в оркестраторы
---
### План занятия
 - Контейнеризация
    - С чего все начиналось
    - Немного терминологии
    - Как использовать
 - Зачем нужны оркестраторы
    - Мотивация
    - Типичные решаемые задачи
    - Примеры оркестраторов
 - Kubernetes (K8S)
    - Немного о строении
    - Элементарные сценарии использования
---
### Этапы большого пути
 - 1979: в ядре UNIX появился системный вызов chroot (первые попытки изоляции файловой системы)
 - 2000: FreeBSD jails (частичная изоляция сетевых интерфейсов)
 - 2002: в ядро Linux было добавлено первое пространство имен (namespace) для изоляции файловой системы 
 - 2006-2007: разработан механизм Process Containers (позднее переименованный в cgroups), изоляция использования группой процессов ЦПУ, ОЗУ и др. аппаратных ресурсов
 - 2008: функционал cgroups был добавлен в ядро Linux
 - 2013: в ядро Linux добавлено пространств имен пользователей – user  
 - 2013: появление платформы Docker
---
### Есть же виртуализация - зачем нужны контейнеры?

![Containers vs VM](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d11/f14/7cb/d11f147cb52abceecf4618ec554cf8fd.png)

Короткий ответ - контейнеры более легковесные, их можно больше разместить на одной хост-машине
 
*конечно, у контейнеров есть недостатки, например, они обеспечивают худший уровень изоляции и за счет этого менее безопасны*<!-- .element: class="small_font"  -->

---
### Терминология. Container image
 Container image (образ) – файл, в который упаковано приложение и его среда. Он содержит файловую систему, которая будет доступна приложению, и другие метаданные (например команды, которые должны быть выполнены при запуске контейнера). Образы контейнеров состоят из слоев (как правило один слой – одна инструкция). Разные образы могут содержать одни и те же слои, поскольку каждый слой надстроен поверх другого образа, а два разных образа могут использовать один и тот же родительский образ в качестве основы. Образы хранятся в Registry Server (реестре) и версионируются с помощью tag (тегов). Если тег не указан, то по умолчанию используется latest<!-- .element: class="left"  -->
---
### Терминология. Registry Server
Registry Server (реестр, хранилище) – это репозиторий, в котором хранятся образы. После создания образа на локальном компьютере его можно отправить (push) в хранилище, а затем извлечь (pull) на другом компьютере и запустить его там. Существуют общедоступные и закрытые реестры образов. Примеры: Docker Hub (репозитории docker.io), Yandex CR<!-- .element: class="left"  -->
---
## Терминология. Container
Container (контейнер) – это экземпляр образа контейнера. Выполняемый контейнер – это запущенный процесс, изолированный от других процессов на сервере и ограниченный выделенным объемом ресурсов (ЦПУ, ОЗУ, диска и др.). Выполняемый контейнер сохраняет все слои образа с доступом на чтение и формирует сверху свой исполняемый слой с доступом на запись.<!-- .element: class="left"  -->
---
### Терминология. Container Engine
Container Engine (движок контейнеризации) – это программная платформа для упаковки, распространения и выполнения приложений, которая скачивает образы и с пользовательской точки зрения запускает контейнеры (на самом деле за создание и запуск контейнеров отвечает Container Runtime). Примеры: Docker, Podman<!-- .element: class="left"  -->
---
### Терминология. Container Runtime
Container Runtime (среда выполнения контейнеров) – программный компонент для создания и запуска контейнеров. Примеры: runc, crun.<!-- .element: class="left"  -->
---
### Терминология. Host
Host (хост) – сервер, на котором запущен Container Engine и выполняются контейнеры.<!-- .element: class="left"  -->
---
### Контейнерная виртуализация
- Поддержка на разных платформах
- Возможность написать dockerfile и запустить его в любом месте, получив гарантированный повторяемый результат
- Можно упаковать свое приложение в стандартный docker контейнер и запустить его сколько угодно раз
- Можно развернуть, например, в docker compose
---
### Зачем нужны оркестраторы
 - Контейнеры очень легковесны, что *провоцирует* на запуск большого их количества
 - использование микросервисной архитектуры *провоцирует* на создание вместо одного приложения множества взаимосвязанных микроприложений
 - как следствие мы получили *гигантское* (десятки и даже сотни тысяч) количество взаимосвязанных контейнеров

## Как ими управлять?
---
### Оркестраторы
- Управление большим количеством
контейнеров
  - На самом деле большим – сотнями, тысячами, десятками тысяч
  - Контроль их состояния, выделение ресурса, перезапуск, балансировка и т.п.
- Для этого так же есть специализированные решения
  - Kubernetes, Openshift, Hashicorp Nomad, Docker swarm, ...
---
### Оркестраторы
- Что еще?
  - service discovery
  - управление секретами
  - автоматическое масштабирование узлов кластера и приложения (горизонтальное масштабирование)
  - работа с ресурсами сервера - вертикальное масштабирование
  - различные стратегии обновления (Rolling, Recreate, Blue/Green, Canary)
  - инфраструктура как код (декларативное описание)
  - .......
---
### Docker Swarm
- (+) Встроенный в docker оркестратор
- (-) Работает только с docker-контейнерами
- (+) Бесплатен
- (+) Простота первоначальной настройки, меньше уровень входа
- (+) Небольшие требования к ресурсам
- (-) Отсутствие встроенной поддержки автоматического масштабирования
---
### Docker Swarm
- (-) Одна стратегия обновления - Rolling update
- (+) Язык манифестов - yaml
- (-) Нет встроенной поддержки шаблонов
- (-) Малая поддержка сообществом - малое количество готовых решений, непопулярная технология у специалистов

https://docs.docker.com/engine/swarm/swarm-tutorial/
---
### Kubernetes & OpenShift
- Рассмотрим вместе - OpenShift базируется на Kubernetes
- Kubernetes
  - Оркестратор, созданный Google и переданный в open-source
  - Среди участников разработки большое количество крупных компаний
  - Linux, Windows
  - Бесплатный (open source)
- Openshift
  - Платформа от RedHat
  - Внутри Kubernetes и много технологий вокруг для доставки кода, мониторинга, сбора логов и т.д.
  - RHEL
  - **Только enterprise версия (платная)**
---
### Kubernetes
- Минимальная рабочая сущность - Pod: docker, cri-o, containerd контейнеры, не обязательно один - единое сетевое и дисковое пространство
- Узлы - Control Plane, Nodes
- Вертикальное автоматическое масштабирование
- Горизонтальное автоматическое масштабирование узлов и приложения
- В облаках можно увеличивать/уменьшать количество нод - экономия
- Из коробки доступны стратегии Rolling update и Recreate
- С помощью расширений можно использовать Blue/Green и Canary
- Основной язык описания конфигурации - Yaml, можно использовать JSON
- С помощью Helm доступна продвинутая шаблонизация
- Большое количество встроенного функционала оркестрации
- Расширение функционала с помощью кастомного API, операторов, сетевых плагинов, инструментов для установки и управления кластером и т.д., как следствие - большие возможности кастомизации






