# Элементарное введение в оркестраторы
---
### План занятия
 - Контейнеризация
    - С чего все начиналось
    - Немного терминологии
    - Как использовать
 - Зачем нужны оркестраторы
    - Мотивация
    - Типичные решаемые задачи
    - Примеры оркестраторов
 - Kubernetes (K8S)
    - Немного о строении
    - Элементарные сценарии использования
---
### Этапы большого пути
 - 1979: в ядре UNIX появился системный вызов chroot (первые попытки изоляции файловой системы)
 - 2000: FreeBSD jails (частичная изоляция сетевых интерфейсов)
 - 2002: в ядро Linux было добавлено первое пространство имен (namespace) для изоляции файловой системы 
 - 2006-2007: разработан механизм Process Containers (позднее переименованный в cgroups), изоляция использования группой процессов ЦПУ, ОЗУ и др. аппаратных ресурсов
 - 2008: функционал cgroups был добавлен в ядро Linux
 - 2013: в ядро Linux добавлено пространств имен пользователей – user  
 - 2013: появление платформы Docker
---
### Есть же виртуализация - зачем нужны контейнеры?

![Containers vs VM](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d11/f14/7cb/d11f147cb52abceecf4618ec554cf8fd.png)

Короткий ответ - контейнеры более легковесные, их можно больше разместить на одной хост-машине
 
*конечно, у контейнеров есть недостатки, например, они обеспечивают худший уровень изоляции и за счет этого менее безопасны*<!-- .element: class="small_font"  -->

---
### Контейнерная виртуализация
- Поддержка на разных платформах
- Возможность написать dockerfile и запустить его в любом месте, получив гарантированный повторяемый результат
- Можно упаковать свое приложение в стандартный docker контейнер и запустить его сколько угодно раз
- Можно развернуть, например, в docker compose
---
### Терминология. Container image
 Container image (образ) – файл, в который упаковано приложение и его среда. Он содержит файловую систему, которая будет доступна приложению, и другие метаданные (например команды, которые должны быть выполнены при запуске контейнера). Образы контейнеров состоят из слоев (как правило один слой – одна инструкция). Разные образы могут содержать одни и те же слои, поскольку каждый слой надстроен поверх другого образа, а два разных образа могут использовать один и тот же родительский образ в качестве основы. Образы хранятся в Registry Server (реестре) и версионируются с помощью tag (тегов). Если тег не указан, то по умолчанию используется latest<!-- .element: class="left"  -->
---
### Терминология. Registry Server
Registry Server (реестр, хранилище) – это репозиторий, в котором хранятся образы. После создания образа на локальном компьютере его можно отправить (push) в хранилище, а затем извлечь (pull) на другом компьютере и запустить его там. Существуют общедоступные и закрытые реестры образов. Примеры: Docker Hub (репозитории docker.io), Yandex CR<!-- .element: class="left"  -->
---
## Терминология. Container
Container (контейнер) – это экземпляр образа контейнера. Выполняемый контейнер – это запущенный процесс, изолированный от других процессов на сервере и ограниченный выделенным объемом ресурсов (ЦПУ, ОЗУ, диска и др.). Выполняемый контейнер сохраняет все слои образа с доступом на чтение и формирует сверху свой исполняемый слой с доступом на запись.<!-- .element: class="left"  -->
---
### Терминология. Container Engine
Container Engine (движок контейнеризации) – это программная платформа для упаковки, распространения и выполнения приложений, которая скачивает образы и с пользовательской точки зрения запускает контейнеры (на самом деле за создание и запуск контейнеров отвечает Container Runtime). Примеры: Docker, Podman<!-- .element: class="left"  -->
---
### Терминология. Container Runtime
Container Runtime (среда выполнения контейнеров) – программный компонент для создания и запуска контейнеров. Примеры: runc, crun.<!-- .element: class="left"  -->
---
### Терминология. Host
Host (хост) – сервер, на котором запущен Container Engine и выполняются контейнеры.<!-- .element: class="left"  -->
---
### Dockerfile
- Kонтейнер Docker — самодостаточная операционная система, в которой
имеется только самое необходимое и код приложения.
- Образы Docker являются результатом процесса их сборки, а контейнеры Docker — это выполняющиеся образы.
- Dockerfile файлы сообщают Docker о том, как собирать образы, на основе которых создаются контейнеры.
- Каждому образу Docker соответствует файл, который называется Dockerfile.
- При запуске команды docker build для создания нового образа подразумевается, что Dockerfile находится в текущей рабочей директории. Если этот файл находится в каком-то другом месте, его расположение можно указать с использованием флага -f.
---
### Dockerfile
- Контейнеры состоят из слоёв.
- Каждый слой, кроме последнего, находящегося поверх всех остальных, предназначен только для чтения.
- Dockerfile сообщает системе Docker о том, какие слои и в каком порядке надо добавить в образ.
- Каждый слой — это файл, который описывает изменение состояния образа в сравнении с тем состоянием, в котором он пребывал после добавления предыдущего слоя.
- Базовый образ — это то, что является исходным слоем (или слоями) создаваемого образа. Базовый образ ещё называют родительским образом.
---
### Dockerfile
- В файлах Dockerfile содержатся инструкции по созданию образа (набираются заглавными буквами). С них начинаются
строки этого файла.
- После инструкций идут их аргументы. 
- Инструкции, при сборке образа, обрабатываются сверху вниз.
- Слои в итоговом образе создают только инструкции FROM, RUN, COPY, и ADD. 
---
### Dockerfile
```dockerfile
# syntax=docker/dockerfile:1
ARG NODE_VERSION=18.0.0
FROM node:${NODE_VERSION}-alpine
WORKDIR /usr/src/app
RUN --mount=type=bind,source=package.json,target=package.json \
    --mount=type=bind,source=package-lock.json,target=package-lock.json \
    --mount=type=cache,target=/root/.npm \
    npm ci --omit=dev
USER node
COPY . .
# Expose the port that the application listens on.
# EXPOSE 3000
# Run the application.
CMD node src/index.js
```
---
|Команда|Описание|
|-----|------|
|FROM| Задаёт базовый (родительский) образ.|
|COPY| Копирует в контейнер файлы и папки.|
|ADD |Копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.|
|WORKDIR| Задаёт рабочую директорию для следующей инструкции.|
|ENV| Устанавливает постоянные переменные среды.|
|ARG| Задаёт переменные для передачи Docker во время сборки образа.|
|LABEL| Описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.|
|RUN| Выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.|
|CMD| Описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD.|
|ENTRYPOINT| Предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.|
|EXPOSE| Указывает на необходимость открыть порт.|
|VOLUME| Создаёт точку монтирования для работы с постоянным хранилищем.|
---
### Некоторые команды
```bash
# справочная информация
docker --help # список доступных команд
docker <command> --help # информация по команде
docker --version # версия Docker
docker info # общая информация о системе

# сборка образа из Dockerfile, лежащего в текущей директории
# и пометка его тегом tag (в конце команды - точка)
docker build -t <tag> .

# работа с образами
docker search nginx # поиск образов по ключевому слову nginx
# скачивание последней версии (тег по умолчанию latest) официального образа nginx  
# (издатель не указывается) из репозитория по умолчанию docker.io/library
docker pull nginx 

# скачивание последней версии (latest) образа prometheus от издателя prom 
# из репозитория docker.io/prom
docker pull prom/prometheus 

# скачивание из репозитория docker.io официального образа ubuntu с тегом 22.04
docker pull docker.io/library/ubuntu:22.04 
```
---
### Некоторые команды
```bash
docker images # просмотр локальных образов
# удаление образа. Вместо <image_name>:<tag> можно указать <image_id>. 
# Для удаления образа все контейнеры на его основе должны быть 
# как минимум остановлены 
docker rmi <image_name>:<tag> 
docker rmi $(docker images -aq) # удаление всех образов

# работа с контейнерами
docker run hello-world # Hello, world! в мире контейнеров
# запуск контейнера ubuntu и выполнение команды bash в интерактивном режиме

docker run -it ubuntu bash 
# запуск контейнера gettind-started с отображением (маппингом) порта 8080 хоста 
# на порт 80 внутрь контейнера

docker run --name docker-getting-started --publish 8080:80 docker/getting-started 
# запуск контейнера mongodb с именем mongodb в фоновом режиме. 
# данные будут удалены при удалении контейнера

docker run --detach --name mongodb docker.io/library/mongo:4.4.10 

```
---
### Некоторые команды
```bash
docker ps # просмотр запущенных контейнеров
docker ps -a # просмотр всех контейнеров (в том числе остановленных)
docker stats --no-stream # просмотр статистики
 
docker start alpine # создание контейнера из образа alpine

# запуск созданного контейнера. 
# Вместо <container_name> можно указать <container_id> 
docker start <container_name> 
docker start $(docker ps -a -q) # запуск всех созданных контейнеров

# остановка контейнера. Вместо <container_name> можно указать <container_id> 
docker stop <container_name> 
docker stop $(docker ps -a -q) # остановка всех контейнеров
# удаление контейнера. Вместо <container_name> можно указать <container_id> 
docker rm <container_name> 
docker rm $(docker ps -a -q) # удаление всех контейнеров
```

---
### Зачем нужны оркестраторы
 - Контейнеры очень легковесны, что *провоцирует* на запуск большого их количества
 - использование микросервисной архитектуры *провоцирует* на создание вместо одного приложения множества взаимосвязанных микроприложений
 - как следствие мы получили *гигантское* (десятки и даже сотни тысяч) количество взаимосвязанных контейнеров

## Как ими управлять?
---
### Оркестраторы
- Управление большим количеством
контейнеров
  - На самом деле большим – сотнями, тысячами, десятками тысяч
  - Контроль их состояния, выделение ресурса, перезапуск, балансировка и т.п.
- Для этого так же есть специализированные решения
  - Kubernetes, Openshift, Hashicorp Nomad, Docker swarm, ...
---
### Оркестраторы
- Что еще?
  - service discovery
  - управление секретами
  - автоматическое масштабирование узлов кластера и приложения (горизонтальное масштабирование)
  - работа с ресурсами сервера - вертикальное масштабирование
  - различные стратегии обновления (Rolling, Recreate, Blue/Green, Canary)
  - инфраструктура как код (декларативное описание)
  - .......
---
### Docker Swarm
- (+) Встроенный в docker оркестратор
- (-) Работает только с docker-контейнерами
- (+) Бесплатен
- (+) Простота первоначальной настройки, меньше уровень входа
- (+) Небольшие требования к ресурсам
- (-) Отсутствие встроенной поддержки автоматического масштабирования
---
### Docker Swarm
- (-) Одна стратегия обновления - Rolling update
- (+) Язык манифестов - yaml
- (-) Нет встроенной поддержки шаблонов
- (-) Малая поддержка сообществом - малое количество готовых решений, непопулярная технология у специалистов

https://docs.docker.com/engine/swarm/swarm-tutorial/
---
### Kubernetes & OpenShift
- Рассмотрим вместе - OpenShift базируется на Kubernetes
- Kubernetes
  - Оркестратор, созданный Google и переданный в open-source
  - Среди участников разработки большое количество крупных компаний
  - Linux, Windows
  - Бесплатный (open source)
- Openshift
  - Платформа от RedHat
  - Внутри Kubernetes и много технологий вокруг для доставки кода, мониторинга, сбора логов и т.д.
  - RHEL
  - **Только enterprise версия (платная)**
---
### Kubernetes
- Минимальная рабочая сущность - Pod: docker, cri-o, containerd контейнеры, не обязательно один - единое сетевое и дисковое пространство
- Узлы - Control Plane, Nodes
- Вертикальное автоматическое масштабирование
- Горизонтальное автоматическое масштабирование узлов и приложения
- В облаках можно увеличивать/уменьшать количество нод - экономия
- Из коробки доступны стратегии Rolling update и Recreate
- С помощью расширений можно использовать Blue/Green и Canary
---
### Kubernetes
- Основной язык описания конфигурации - Yaml, можно использовать JSON
- С помощью Helm доступна продвинутая шаблонизация
- Большое количество встроенного функционала оркестрации
- Расширение функционала с помощью кастомного API, операторов, сетевых плагинов, инструментов для установки и управления кластером и т.д., как следствие - большие возможности кастомизации
- Большое сообщество, сильная заинтересованность в технологии
---
### Kubernetes
- Обычно управление кластером Kubernetes выполняется из командной строки с помощью CLI kubectl
- На вход kubectl подается манифест с описанием желаемого состояния кластера. Получив эту информацию Kubernetes пытается привести текущее состояние к желаемому. Для этого Kubernetes автоматически выполняет множество задач, таких как запуск или перезапуск контейнеров, масштабирование количества реплик данного приложения и многое другое.
- Кластер Kubernetes разворачивается на нодах, при этом каждая нода может быть в роли Master или Worker. Master ноды занимаются управлением кластером и распределением задач на Worker. Worker используются для запуска контейнеров. Kubernetes состоит из набора процессов и демонов на каждой ноде в кластере.
---
### Kubernetes
![Кластер Kubernetes](https://github.com/Romanow/lectures/raw/master/kubernetes/images/kubernetes/kubernetes.png)

Кластер Kubernetes состоит из набора машин, называемых нода (Node), которые запускают контейнеризированные приложения. Каждая нода содержит поды (Pod) – минимальная сущность для развертывания в кластере. K8S управляет подами, а не контейнерами напрямую<!-- .element: class="small_font"  -->
---
### Master-ноды
- kube-apiserver (API-сервер) – клиентская часть панели управления кластером
- kube-controller-manager – Компонент Control Plane запускает процессы контроллера. Каждый контроллер в свою очередь представляет собой отдельный процесс, и для упрощения все такие процессы скомпилированы в один двоичный файл и выполняются в одном процессе. 
- kube-scheduler – компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать. 
- cloud-controller-manager – запускает контроллеры, которые взаимодействуют с основными облачными провайдерами. 
- etcd - key-value хранилище, которое используется как основное хранилище всех данных в кластере Kubernetes. 
---
### Worker -ноды
- Каждая Worker нода в кластере выполняет два процесса:
  - kubelet – Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде. Утилита kubelet принимает набор PodSpecs, и гарантирует работоспособность и исправность определённых в них контейнеров.
  - kube-proxy – сетевой прокси, работающий на каждом узле в кластере. kube-proxy конфигурирует правила сети на узлах, при помощи них разрешаются сетевые подключения к Pod изнутри и снаружи кластера. kube-proxy использует уровень фильтрации пакетов в операционной системы, если он доступен. В противном случае, kube-proxy сам обрабатывает передачу сетевого трафика.
---
### Основные объекты Kubernetes
- Pod: минимальная сущность для развертывания в кластере. Каждый Pod предназначен для запуска одного (обычно) экземпляра конкретного приложения. Если есть необходимость горизонтального масштабирования, то можно запустить несколько экземпляров Pod - в терминологии Kubernetes это называется репликацией
- Service: Абстракция, которая определяет логический набор подов и политику доступа к ним, как сетевой сервис. Pod создаются и удаляются, чтобы поддерживать описанное состояние кластера. Каждый pod имеет свой ip-адрес, но эти адреса не постоянны и могут меняться со временем (при переезде между нодами, например).


---
### Основные объекты Kubernetes
- Volumes: Персистентное хранилище данных внутри кластера. По умолчанию используется emptyDir – volume создается на диске и существует до тех пор, пока Pod работает на этой ноде. ConfigMaps так же могут использоваться как volume для конфигурирования приложения.
- Namespace: пространства имен, в которые помещаются вс остальные объекты. 
- Secrets: используются для хранения конфиденциальной информации.
---
### Производные объекты Kubernetes
Kubernetes также содержит абстракции более высокого уровня, которые опираются на Контроллеры (Controller) для создания базовых объектов и предоставляют дополнительные функциональные и удобные функции. Они включают:<!-- .element: class="left"  -->

- Deployment: обеспечивает декларативные обновления для Pods и ReplicaSets. Наиболее распространенный тип описания ресурсов, состоит из секции описания Pod (.spec.template), Labels (.spec.template.metadata.labels), информация о репликации (.spec.replicas).
- DaemonSet: гарантирует, что определенный Pod будет запущен на всех нодах.
---
### Производные объекты Kubernetes
- StatefulSet: используется для управления приложениями с сохранением состояния.
- ReplicaSet: гарантирует, что определенное количество экземпляров Pod будет запущено в кластере в любой момент времени.
- Labels: используются для маркирования объектов кластера, а так же для выбора этих объектов 
- ConfigMaps: абстракция над файлами конфигурации, позволяет разделять настройки приложения и сами контейнеры, избавляя от необходимости упаковывать конфиги в docker-образ.
---
### Развертывание приложений
---




