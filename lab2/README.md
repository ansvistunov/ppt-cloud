## Лабораторная работа №2

# Цель
1. Модифицировать готовое приложение (исходный репозиторий https://github.com/docker/docker-nodejs-sample.git), подготовить его образ
2. Загрузить образ приложения в Container Registry
3. Подготовить Serverless container на базе этого образа

# Введение
Есть готовое приложение, простейший менеджер задач. Приложение может работать в двух режимах - с использованием "локальной" базы sqllite и с использованием внешнего сервера Postgres. Мы будем использовать модель запуска Serverless container, и поэтому не сможем использовать локальную БД - время жизни Serverless container нам гарантируется только на момент выполнения запроса (подробнее про модель смотри https://cloud.yandex.ru/ru/docs/serverless-containers/service-comparison). Поэтому первое, что нам необходимо сделать - подключить нашу программу к БД Postgres. Делается это путем передачи в программу параметров окружения

```pre
POSTGRES_HOST: 
POSTGRES_PORT: 
NODE_ENV: 
POSTGRES_DB: 
POSTGRES_USER: 
POSTGRES_PASSWORD: 
```

которые задают подключение к БД. В качестве БД мы будем использовать Managed Service for PostgreSQL, развернутый в нашем облаке. Публиковать мы нашу БД не будем, таким образом доступ к ней будет невозможен из внешней сети.
Все наши записи мы будем хранить в одной таблице, таким образом необходим механизм, который позволит разделить записи разных пользователей. В качестве такого механизма мы будем использовать поле section таблицы todo_items.
Таким образом, все записи с одним и тем же значением section будут относиться к одному "пользователю":

|№|id|section|name|completed|
|-|-|-|-|-|
|0|"0e61cace-2d30-4efe-ae56-bd64ff50aa98"|"ivanov"|"item 1"|false|
|1|"eb9ee5bf-2b60-4905-803f-37e23563793f"|"petrov"|"test 2"|false|
|2|"1a931ff9-f160-4ac6-be1a-417cfcedba2c"|"petrov"|"test 1"|true|
|3|"d38a6551-1dab-4e24-a259-622f627eb1d0"|"petrov"|"item 2"|false|
|4|"e2c71f19-54eb-4925-8af8-f1f39bce0e5b"|"petrov"|"это новый итем 2"|true|
|5|"a987b0ad-acda-406a-a815-b3e5fcf56415"|"petrov"|"this is text 5"|false|
|6|"93e6b80e-d4db-4af6-bbe5-e41fe52a8cb9"|"sidorov"|"это новый итем 1"|true|
|7|"1b65cf0a-c97c-4bd3-86a3-79bd2f924eae"|"sidorov"|"это новый итем 4"|false|
|8|"66694fbd-f092-4624-afec-88619ead2456"|"sidorov"|"это новый "|false|
|9|"5dc0c1f1-a018-49c4-aecb-af1c35069553"|"ivanov"|" i 1"|false|
|10|"042410ca-51eb-4e6c-b7c3-e8ce0a3cd3cc"|"ivanov"|"i 2"|true|
|11|"7a044d09-baf8-4809-97f3-9cac147ed900"|"ivanov"|"i 3"|true|

# Модификация кода программы
1. Программа, которую мы будем использовать, не приспособлена для работы в режиме serverless. Мы попытаемся ее модифицировать таким образом, чтобы она "правильно" заработала в этом режиме. Все правки мы будем делать в файле src\persistence\postgres.js
2. Первое, что нам необходимо поправить - SQL запросы. Обратите внимание, у нас добавился столбец таблицы section. Нам необходимо при загрузке строк фильтровать по этому столбцу, а при создании новой строки добавить его в год вставки.
3. Обратите внимание - соединение с сервером БД программа устанавливает один раз - при своем старте. И далее использует для работы уже установленное соединение. Подумайте, подходит ли нам такое поведение. 
4. При загрузке вашего приложения в браузер формируется много запросов на статические ресурсы. **Не обязательно**, что все эти запросы попадут в один и тот же запущенный экземпляр вашего контейнера. Система может попытаться в этот момент отмасштабироваться, и тогда будет запущено несколько экземпляров вашего контейнера. Вы можете это отследить, просматривая логи (идите к вашему контейнеру и перейдите на вкладку логи). Если при старте вашего контейнера вы что-то пишите в консоль, вы можете увидеть несколько таких записей (что будет означать, что запущено несколько экземпляров контейнера)
5. Контейнер не живет долго - его гарантированное время жизни - это обработка запроса (при условии, что это время обработки не превышает таймаут). Вы не можете полагаться на то, что контейнер будет завершен "корректно". Вы можете увидеть в логах сообщения об обрыве соединений - они возникают в момент завершения контейнера, когда разрывается соединение с БД (подумайте, как "корректно" завершать соединение с БД).

# Создание образа
1. в папке lab2/docker-nodejs-sample вводим команду (в конце команды стоит точка!)
```bash
docker build -t todo-app-<ваша фамилия>:latest .
```

2. убеждаемся, что образ собран:
docker images
ищем в выводе свой образ, смотрим на дату и время его создания

# Регистрация в Container Registry
1. регистрируемся, для того чтобы подучить права на загрузку образов в Container Registry
Идем по ссылке https://oauth.yandex.ru/authorize?response_type=token&client_id=1a6990aa636648e9b2ef855fa7bec2fb ,входим под своим пользователем. Копируем значение токена

2. вводим команду
```bash 
docker login --username oauth --password <ваш токен> cr.yandex 
```
 - мы зарегистрировались для загрузки в реестр

# Загружаем образ в Container Registry
1.  "переименовываем" ранее созданный образ:
```bash
docker tag todo-app-<ваша фамилия>:latest cr.yandex/<узнайте идентификатор реестра у преподавателя>/todo-app-<ваша фамилия>:latest
```

2. после этого загружаем наш образ в реестр:
```bash
docker push cr.yandex/<узнайте идентификатор реестра у преподавателя>/todo-app-<ваша фамилия>:latest
```

3. Идем в Container Registry, убеждаемся что подготовленный вами образ появился в нем

# Создание Serverless container
1. Идем в Serverless containers, создаем новый контейнер с параметрами:

имя контейнера - todo-app-<ваша фамилия>-container
vCPU: 1 (оставляем без изменений)
Гарантированная доля vCPU: 5%
RAM: 128МБ (оставляем без изменений)

URL образа: выбираем загруженный вами образ (его имя - ) todo-app-<ваша фамилия>
Тег - latest

Переменные окружения
POSTGRES_HOST: <спросите у преподавателя>
POSTGRES_PORT: 6432
NODE_ENV: production
POSTGRES_DB: db1
SECTION: <ваша фамилия>

Секреты Yandex Lockbox: 
POSTGRES_USER из секрета key_for_postres выбираем значение DBUSER
POSTGRES_PASSWORD из секрета key_for_postres выбираем значение DBPASSWORD

Сервисный аккаунт: image puller
Сеть: default

Все остальные параметры оставляем по умолчанию:
Количество одновременных вызовов экземпляра контейнера: 1
Количество подготовленных экземпляров: 0

После создания контейнера - публикуем его (нажимаем соответствующий переключатель)


*Обратите внимание! Если вы внесли изменения, собрали новый образ и выложили его, вам нужно войти в контейнер и нажать кнопку "Создать ревизию", без этого изменения к контейнеру не будут применены.*
